From: Arturo Buzarra <arturo.buzarra@digi.com>
Date: Wed, 18 May 2022 10:58:20 +0200
Subject: [PATCH] qcacld-3.0: cfg: try to get MACs from device tree entries
 before reading 'wlan_mac.bin' file

This commits adds support to read the MAC addresses from symbolic link files
('wlan_macX' files inside 'wlan' directory) pointing to device tree MAC entries
('/proc/device-tree/wireless/mac-addressX').
If this read fails, the 'wlan/wlan_mac.bin' file contents are parsed.

This change avoids the dynamic creation of the 'wlan_mac.bin' configuration file
in runtime, especially for Android.

https://onedigi.atlassian.net/browse/ADK4A-1585
https://onedigi.atlassian.net/browse/DEL-7916

Signed-off-by: Isaac Hermida <isaac.hermida@digi.com>
Signed-off-by: Tatiana Leon <tatiana.leon@digi.com>
(based on qcacld-2.0 0a92f5d9e8df644de74e74f152ed6ff3dd8d3369)
Signed-off-by: Arturo Buzarra <arturo.buzarra@digi.com>
---
 core/hdd/inc/wlan_hdd_cfg.h  |  1 +
 core/hdd/inc/wlan_hdd_misc.h |  2 ++
 core/hdd/src/wlan_hdd_cfg.c  | 65 ++++++++++++++++++++++++++++++++++++
 core/hdd/src/wlan_hdd_main.c |  6 ++++
 4 files changed, 74 insertions(+)

diff --git a/core/hdd/inc/wlan_hdd_cfg.h b/core/hdd/inc/wlan_hdd_cfg.h
index 36aa010db9..1527aaf87e 100644
--- a/core/hdd/inc/wlan_hdd_cfg.h
+++ b/core/hdd/inc/wlan_hdd_cfg.h
@@ -276,10 +276,11 @@ struct hdd_config {
  *
  * Return: CSR WMM mode
  */
 eCsrRoamWmmUserModeType hdd_to_csr_wmm_mode(uint8_t mode);
 
+QDF_STATUS hdd_update_mac_from_dt(struct hdd_context *hdd_ctx);
 QDF_STATUS hdd_update_mac_config(struct hdd_context *hdd_ctx);
 QDF_STATUS hdd_set_sme_config(struct hdd_context *hdd_ctx);
 QDF_STATUS hdd_set_policy_mgr_user_cfg(struct hdd_context *hdd_ctx);
 QDF_STATUS hdd_set_sme_chan_list(struct hdd_context *hdd_ctx);
 bool hdd_update_config_cfg(struct hdd_context *hdd_ctx);
diff --git a/core/hdd/inc/wlan_hdd_misc.h b/core/hdd/inc/wlan_hdd_misc.h
index b105df1b3a..6d9bf450ef 100644
--- a/core/hdd/inc/wlan_hdd_misc.h
+++ b/core/hdd/inc/wlan_hdd_misc.h
@@ -42,11 +42,13 @@
 #endif
 
 #ifdef MSM_PLATFORM
 #define WLAN_INI_FILE              "wlan/qca_cld/" PREFIX "WCNSS_qcom_cfg.ini"
 #define WLAN_MAC_FILE              "wlan/qca_cld/" PREFIX "wlan_mac.bin"
+#define WLAN_MAC_DT_FILE           "wlan/qca_cld/" PREFIX "wlan_mac"
 #else
 #define WLAN_INI_FILE              "wlan/" PREFIX "qcom_cfg.ini"
 #define WLAN_MAC_FILE              "wlan/" PREFIX "wlan_mac.bin"
+#define WLAN_MAC_DT_FILE           "wlan/" PREFIX "wlan_mac"
 #endif /* MSM_PLATFORM */
 
 #endif /* WLAN_HDD_MISC_H */
diff --git a/core/hdd/src/wlan_hdd_cfg.c b/core/hdd/src/wlan_hdd_cfg.c
index b12e42c74c..c921a93642 100644
--- a/core/hdd/src/wlan_hdd_cfg.c
+++ b/core/hdd/src/wlan_hdd_cfg.c
@@ -197,10 +197,75 @@ int hdd_firmware_request_nowarn(const struct firmware **fw,
 {
 	return request_firmware(fw, name, device);
 }
 #endif
 
+/**
+ * hdd_update_mac_from_dt() - update MAC address from device tree
+ * @hdd_ctx: the pointer to hdd context
+ *
+ * It overwrites the MAC address if device tree entries exist.
+ *
+ * Return: QDF_STATUS_SUCCESS if the MAC address is found from device tree
+ *      and overwritten, otherwise QDF_STATUS_E_INVAL
+ */
+QDF_STATUS hdd_update_mac_from_dt(struct hdd_context *hdd_ctx)
+{
+	int status, i = 0;
+	const struct firmware *fw = NULL;
+	char fName[20];
+	int max_mac_addr = QDF_MAX_CONCURRENCY_PERSONA;
+	tSirMacAddr custom_mac_addr;
+
+	QDF_STATUS qdf_status = QDF_STATUS_SUCCESS;
+
+	for (i = 0; i < max_mac_addr; i++)
+	{
+		sprintf(fName, WLAN_MAC_DT_FILE "%d", i);
+
+		status = hdd_firmware_request_nowarn(&fw, fName,
+						     hdd_ctx->parent_dev);
+		if (!status && fw && fw->data && fw->size)
+		{
+			/* Successfully read mac from device tree */
+			qdf_mem_copy((uint8_t *)&hdd_ctx->provisioned_mac_addr[i].bytes[0],
+				     fw->data, QDF_MAC_ADDR_SIZE);
+			hdd_ctx->num_provisioned_addr++;
+		}
+		else
+		{
+			hdd_err("Reading MAC address from device tree failed (%s)", fName);
+			status = 1;
+		}
+		release_firmware(fw);
+		fw = NULL;
+
+		/* Only fail if the first MAC cannot be read. */
+		if (status && i == 0) {
+			qdf_status = QDF_STATUS_E_FAILURE;
+			goto dt_exit;
+		}
+	}
+
+	if (hdd_ctx->num_provisioned_addr != 0 && hdd_ctx->num_provisioned_addr <= max_mac_addr) {
+		hdd_info("%d MAC addresses provided from device tree", hdd_ctx->num_provisioned_addr);
+	} else {
+		hdd_err("invalid number of MAC address provided, nMac = %d", hdd_ctx->num_provisioned_addr);
+		qdf_status = QDF_STATUS_E_INVAL;
+		goto dt_exit;
+	}
+
+	qdf_mem_copy(&custom_mac_addr,
+		     &hdd_ctx->provisioned_mac_addr[0].bytes[0],
+		     sizeof(tSirMacAddr));
+
+	sme_set_custom_mac_addr(custom_mac_addr);
+
+dt_exit:
+	return qdf_status;
+}
+
 /**
  * hdd_update_mac_config() - update MAC address from cfg file
  * @hdd_ctx: the pointer to hdd context
  *
  * It overwrites the MAC address if config file exist.
diff --git a/core/hdd/src/wlan_hdd_main.c b/core/hdd/src/wlan_hdd_main.c
index 0043de21f1..03138b61ce 100644
--- a/core/hdd/src/wlan_hdd_main.c
+++ b/core/hdd/src/wlan_hdd_main.c
@@ -13588,10 +13588,16 @@ static int hdd_initialize_mac_address(struct hdd_context *hdd_ctx)
 	} else if (hdd_ctx->config->mac_provision) {
 		hdd_err("getting MAC address from platform driver failed");
 		return ret;
 	}
 
+	status = hdd_update_mac_from_dt(hdd_ctx);
+	if (QDF_IS_STATUS_SUCCESS(status)) {
+		hdd_info("using MAC address from device tree");
+		return 0;
+	}
+
 	status = hdd_update_mac_config(hdd_ctx);
 	if (QDF_IS_STATUS_SUCCESS(status)) {
 		hdd_info("using MAC address from wlan_mac.bin");
 		return 0;
 	}
