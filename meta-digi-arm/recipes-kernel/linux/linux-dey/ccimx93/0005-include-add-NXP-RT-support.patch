From b1f8c7c885dc4c9619cfc1232bb380c1dd229a90 Mon Sep 17 00:00:00 2001
From: Mike Engel <Mike.Engel@digi.com>
Date: Fri, 23 Feb 2024 12:30:39 +0100
Subject: [PATCH 05/10] include: add NXP RT support

Signed-off-by: Mike Engel <Mike.Engel@digi.com>
---
 include/dt-bindings/clock/imx8-clock.h |  10 +++
 include/dt-bindings/rpmsg/imx_srtm.h   |  20 +++++
 include/linux/clk/imx-pll.h            |  26 ++++++
 include/linux/console.h                |  33 ++++++-
 include/linux/dsa/netc.h               |  56 ++++++++++++
 include/linux/dsa/sja1105.h            |   2 +
 include/linux/entry-common.h           |   8 +-
 include/linux/ethtool.h                |   7 ++
 include/linux/fec.h                    | 119 +++++++++++++++++++++++++
 include/linux/fsl_qman.h               |   8 ++
 include/linux/interrupt.h              |  29 ++++++
 include/linux/ipi_baremetal.h          |  27 ++++++
 include/linux/lockdep.h                |   1 -
 include/linux/net.h                    |   2 +
 include/linux/netdevice.h              |  48 ++++++++++
 include/linux/preempt.h                |  54 ++++++++++-
 include/linux/printk.h                 |  15 ++++
 include/linux/rpmsg/imx_srtm.h         |  65 ++++++++++++++
 include/linux/sched.h                  |  37 ++++++++
 include/linux/serial_8250.h            |   5 ++
 include/linux/thread_info.h            |  12 ++-
 include/linux/trace_events.h           |  10 ++-
 include/linux/u64_stats_sync.h         |  12 ---
 include/net/dsa.h                      |  18 ++++
 include/net/pkt_cls.h                  |  10 ---
 include/net/pkt_sched.h                |  11 +++
 include/net/switchdev.h                |   1 +
 include/soc/mscc/ocelot.h              |   5 ++
 include/soc/mscc/ocelot_vcap.h         |   1 +
 include/uapi/linux/ethtool.h           |  30 +++++++
 include/uapi/linux/ethtool_netlink.h   |  21 +++++
 include/uapi/linux/virtio_ids.h        |   1 +
 include/uapi/linux/virtio_mmio.h       |   7 +-
 include/uapi/linux/virtio_trans.h      |  60 +++++++++++++
 34 files changed, 740 insertions(+), 31 deletions(-)
 create mode 100644 include/dt-bindings/rpmsg/imx_srtm.h
 create mode 100644 include/linux/clk/imx-pll.h
 create mode 100644 include/linux/dsa/netc.h
 create mode 100644 include/linux/ipi_baremetal.h
 create mode 100644 include/linux/rpmsg/imx_srtm.h
 create mode 100644 include/uapi/linux/virtio_trans.h

diff --git a/include/dt-bindings/clock/imx8-clock.h b/include/dt-bindings/clock/imx8-clock.h
index 2a1122928062..c5d884409872 100644
--- a/include/dt-bindings/clock/imx8-clock.h
+++ b/include/dt-bindings/clock/imx8-clock.h
@@ -61,4 +61,14 @@
 
 #define IMX_ADMA_ACM_CLK_END				50
 
+/* ACM GPT Event Mux Control Register Offset */
+#define IMX_ADMA_ACM_GPT0_CAPIN1_SEL			0x80004
+#define IMX_ADMA_ACM_GPT0_CAPIN2_SEL			0x80008
+#define IMX_ADMA_ACM_GPT1_CAPIN1_SEL			0x90004
+#define IMX_ADMA_ACM_GPT1_CAPIN2_SEL			0x90008
+
+/* ACM GPT Event Mux Select Control */
+#define IMX_ADMA_ACM_GPT_EVENT_INPUT_ETH0		3
+#define IMX_ADMA_ACM_GPT_EVENT_INPUT_ETH1		4
+
 #endif /* __DT_BINDINGS_CLOCK_IMX_H */
diff --git a/include/dt-bindings/rpmsg/imx_srtm.h b/include/dt-bindings/rpmsg/imx_srtm.h
new file mode 100644
index 000000000000..644ab9ceb407
--- /dev/null
+++ b/include/dt-bindings/rpmsg/imx_srtm.h
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright 2023 NXP
+ *
+ */
+
+#ifndef _DT_BINDINGS_RPMSG_IMX_SRTM_H
+#define _DT_BINDINGS_RPMSG_IMX_SRTM_H
+
+/* Bit 0 as RPMSG Over UART flag */
+#define IMX_SRTM_RPMSG_OVER_UART_FLAG (1 << 0)
+#define IMX_SRTM_UART_SUPPORT_MULTI_UART_MSG_FLAG (1 << 1)
+/* [15:11]: port number, such as /dev/ttySRTM3, 3 is the port number */
+#define IMX_SRTM_UART_PORT_NUM_SHIFT (11U)
+#define IMX_SRTM_UART_PORT_NUM_MASK (0x1F << 11U)
+/* [10]: 0b1, specify port number; 0b0, not specify port number */
+#define IMX_SRTM_UART_SPECIFY_PORT_NUM_SHIFT (10U)
+#define IMX_SRTM_UART_SPECIFY_PORT_NUM_MASK (1 << IMX_SRTM_UART_SPECIFY_PORT_NUM_SHIFT)
+
+#endif
diff --git a/include/linux/clk/imx-pll.h b/include/linux/clk/imx-pll.h
new file mode 100644
index 000000000000..9759ca15a6cc
--- /dev/null
+++ b/include/linux/clk/imx-pll.h
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2018 NXP
+ *
+ */
+
+#ifndef __LINUX_CLK_IMX_PLL_H__
+#define __LINUX_CLK_IMX_PLL_H__
+
+enum clk_imx_pll_error {
+	 IMX_CLK_PLL_SUCCESS = 0,
+	 IMX_CLK_PLL_INVALID_PARAM,
+	 IMX_CLK_PLL_PREC_ERR,
+	 IMX_CLK_PLL_LOCK_ERR,
+};
+
+struct clk_imx_pll;
+
+struct clk_imx_pll *clk_imx_pll_get_by_name(const char *name);
+int clk_imx_pll_adjust(struct clk_imx_pll *pll, int *ppb);
+unsigned long clk_imx_pll_get_rate(struct clk_imx_pll *pll,
+				   unsigned long parent_rate);
+int clk_imx_pll_set_rate(struct clk_imx_pll *pll, unsigned long rate,
+			 unsigned long parent_rate);
+
+#endif /*__LINUX_CLK_IMX_PLL_H__*/
diff --git a/include/linux/console.h b/include/linux/console.h
index 8c1686e2c233..8a813cbaf928 100644
--- a/include/linux/console.h
+++ b/include/linux/console.h
@@ -16,6 +16,7 @@
 
 #include <linux/atomic.h>
 #include <linux/types.h>
+#include <linux/mutex.h>
 
 struct vc_data;
 struct console_font_op;
@@ -137,9 +138,19 @@ static inline int con_debug_leave(void)
 #define CON_BRL		(32) /* Used for a braille device */
 #define CON_EXTENDED	(64) /* Use the extended output format a la /dev/kmsg */
 
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+struct console_atomic_data {
+	u64	seq;
+	char	*text;
+	char	*ext_text;
+	char	*dropped_text;
+};
+#endif
+
 struct console {
 	char	name[16];
 	void	(*write)(struct console *, const char *, unsigned);
+	void	(*write_atomic)(struct console *, const char *, unsigned);
 	int	(*read)(struct console *, char *, unsigned);
 	struct tty_driver *(*device)(struct console *, int *);
 	void	(*unblank)(void);
@@ -152,7 +163,26 @@ struct console {
 	uint	ispeed;
 	uint	ospeed;
 	u64	seq;
-	unsigned long dropped;
+	atomic_long_t dropped;
+#ifdef CONFIG_HAVE_ATOMIC_CONSOLE
+	struct console_atomic_data *atomic_data;
+#endif
+	struct task_struct *thread;
+	bool	blocked;
+
+	/*
+	 * The per-console lock is used by printing kthreads to synchronize
+	 * this console with callers of console_lock(). This is necessary in
+	 * order to allow printing kthreads to run in parallel to each other,
+	 * while each safely accessing the @blocked field and synchronizing
+	 * against direct printing via console_lock/console_unlock.
+	 *
+	 * Note: For synchronizing against direct printing via
+	 *       console_trylock/console_unlock, see the static global
+	 *       variable @console_kthreads_active.
+	 */
+	struct mutex lock;
+
 	void	*data;
 	struct	 console *next;
 };
@@ -167,6 +197,7 @@ extern int console_set_on_cmdline;
 extern struct console *early_console;
 
 enum con_flush_mode {
+	CONSOLE_ATOMIC_FLUSH_PENDING,
 	CONSOLE_FLUSH_PENDING,
 	CONSOLE_REPLAY_ALL,
 };
diff --git a/include/linux/dsa/netc.h b/include/linux/dsa/netc.h
new file mode 100644
index 000000000000..a5aef045f1b5
--- /dev/null
+++ b/include/linux/dsa/netc.h
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright 2023 NXP
+ */
+
+#ifndef _NET_DSA_NETC_H
+#define _NET_DSA_NETC_H
+
+#include <linux/kthread.h>
+#include <linux/skbuff.h>
+#include <linux/dsa/8021q.h>
+#include <net/dsa.h>
+
+#define ETH_P_NETC		0x88A8
+#define ETH_P_NETC_META		0x0008
+
+#define NETC_DEFAULT_VLAN	1
+
+#define IFH_TAG_TYPE_C		0
+#define IFH_TAG_TYPE_S		1
+
+/* IEEE 802.3 Annex 57A: Slow Protocols PDUs (01:80:C2:xx:xx:xx) */
+#define NETC_LINKLOCAL_FILTER_A		0x0180C2000000ull
+#define NETC_LINKLOCAL_FILTER_A_MASK	0xFFFFFF000000ull
+
+/* IEEE 1588 Annex F: Transport of PTP over Ethernet (01:1B:19:xx:xx:xx) */
+#define NETC_LINKLOCAL_FILTER_B		0x011B19000000ull
+#define NETC_LINKLOCAL_FILTER_B_MASK	0xFFFFFF000000ull
+
+struct netc_deferred_xmit_work {
+	struct dsa_port *dp;
+	struct sk_buff *skb;
+	struct kthread_work work;
+};
+
+struct netc_skb_cb {
+	struct sk_buff *clone;
+	u64 tstamp;
+	u8 ts_id;
+};
+
+#define NETC_SKB_CB(skb) \
+	((struct netc_skb_cb *)((skb)->cb))
+
+struct netc_tagger_data {
+	void (*xmit_work_fn)(struct kthread_work *work);
+};
+
+static inline struct netc_tagger_data *
+netc_tagger_data(struct dsa_switch *ds)
+{
+	WARN_ON_ONCE(ds->dst->tag_ops->proto != DSA_TAG_PROTO_NETC);
+	return ds->tagger_data;
+}
+
+#endif /* _NET_DSA_NETC_H */
diff --git a/include/linux/dsa/sja1105.h b/include/linux/dsa/sja1105.h
index c177322f793d..31779f9bc92b 100644
--- a/include/linux/dsa/sja1105.h
+++ b/include/linux/dsa/sja1105.h
@@ -35,6 +35,8 @@
 #define SJA1105_META_SMAC			0x222222222222ull
 #define SJA1105_META_DMAC			0x0180C200000Eull
 
+#define SJA1105_MAX_NUM_PCP			8
+
 enum sja1110_meta_tstamp {
 	SJA1110_META_TSTAMP_TX = 0,
 	SJA1110_META_TSTAMP_RX = 1,
diff --git a/include/linux/entry-common.h b/include/linux/entry-common.h
index d95ab85f96ba..3dc3704a3cdb 100644
--- a/include/linux/entry-common.h
+++ b/include/linux/entry-common.h
@@ -57,9 +57,15 @@
 # define ARCH_EXIT_TO_USER_MODE_WORK		(0)
 #endif
 
+#ifdef CONFIG_PREEMPT_LAZY
+# define _TIF_NEED_RESCHED_MASK	(_TIF_NEED_RESCHED | _TIF_NEED_RESCHED_LAZY)
+#else
+# define _TIF_NEED_RESCHED_MASK	(_TIF_NEED_RESCHED)
+#endif
+
 #define EXIT_TO_USER_MODE_WORK						\
 	(_TIF_SIGPENDING | _TIF_NOTIFY_RESUME | _TIF_UPROBE |		\
-	 _TIF_NEED_RESCHED | _TIF_PATCH_PENDING | _TIF_NOTIFY_SIGNAL |	\
+	 _TIF_NEED_RESCHED_MASK | _TIF_PATCH_PENDING | _TIF_NOTIFY_SIGNAL |	\
 	 ARCH_EXIT_TO_USER_MODE_WORK)
 
 /**
diff --git a/include/linux/ethtool.h b/include/linux/ethtool.h
index 15893c3b2c55..c9fffafc4e6b 100644
--- a/include/linux/ethtool.h
+++ b/include/linux/ethtool.h
@@ -609,6 +609,8 @@ struct ethtool_module_power_mode_params {
  * @get_ethtool_phy_stats: Return extended statistics about the PHY device.
  *	This is only useful if the device maintains PHY statistics and
  *	cannot use the standard PHY library helpers.
+ * @get_preempt: Get the network device Frame Preemption parameters.
+ * @set_preempt: Set the network device Frame Preemption parameters.
  * @get_phy_tunable: Read the value of a PHY tunable.
  * @set_phy_tunable: Set the value of a PHY tunable.
  * @get_module_eeprom_by_page: Get a region of plug-in module EEPROM data from
@@ -736,6 +738,11 @@ struct ethtool_ops {
 				      struct ethtool_fecparam *);
 	int	(*set_fecparam)(struct net_device *,
 				      struct ethtool_fecparam *);
+	int	(*get_preempt)(struct net_device *,
+			       struct ethtool_fp *);
+	int	(*set_preempt)(struct net_device *,
+			       struct ethtool_fp *);
+	int	(*reset_preempt)(struct net_device *, bool enable);
 	void	(*get_ethtool_phy_stats)(struct net_device *,
 					 struct ethtool_stats *, u64 *);
 	int	(*get_phy_tunable)(struct net_device *,
diff --git a/include/linux/fec.h b/include/linux/fec.h
index 9aaf53f07269..e72014b995c4 100644
--- a/include/linux/fec.h
+++ b/include/linux/fec.h
@@ -19,4 +19,123 @@ struct fec_platform_data {
 	void (*sleep_mode_enable)(int enabled);
 };
 
+/* The number of Tx and Rx buffers.  These are allocated from the page
+ * pool.  The code may assume these are power of two, so it it best
+ * to keep them that size.
+ * We don't need to allocate pages for the transmitter.  We just use
+ * the skbuffer directly.
+ */
+
+#define FEC_ENET_XDP_HEADROOM (XDP_PACKET_HEADROOM)
+#define FEC_ENET_RX_PAGES	256
+#define FEC_ENET_RX_FRSIZE    (PAGE_SIZE - FEC_ENET_XDP_HEADROOM \
+		- SKB_DATA_ALIGN(sizeof(struct skb_shared_info)))
+#define FEC_ENET_RX_FRPPG	(PAGE_SIZE / FEC_ENET_RX_FRSIZE)
+#ifdef CONFIG_AVB_SUPPORT
+#define FEC_RX_RING_SIZE	256
+#define FEC_ENET_AVB_RX_FRSIZE	1522
+#else
+#define FEC_RX_RING_SIZE	(FEC_ENET_RX_FRPPG * FEC_ENET_RX_PAGES)
+#endif
+#define FEC_ENET_TX_FRSIZE	2048
+#define FEC_ENET_TX_FRPPG	(PAGE_SIZE / FEC_ENET_TX_FRSIZE)
+
+#ifdef CONFIG_AVB_SUPPORT
+#define FEC_TX_RING_SIZE	256	/* Must be power of two */
+#else
+#define FEC_TX_RING_SIZE	512	/* Must be power of two */
+#endif
+
+#ifdef CONFIG_AVB_SUPPORT
+struct avb_desc {
+	u16 offset;
+	u16 len;
+	u32 ts;
+	u32 flags;
+	u32 private; /* Will be used for saving userspace private value on TX and esc hw descriptor value on RX */
+};
+
+struct avb_tx_desc {
+	struct avb_desc common;
+
+	unsigned long dma_addr;
+	void *data;
+	u32 esc;
+	unsigned short queue_id;
+	unsigned short sc;
+	unsigned long bufaddr;
+	unsigned short datlen;
+};
+
+struct avb_rx_desc {
+	struct avb_desc common;
+
+	/* end of common rx fields */
+	unsigned long dma_addr;
+	unsigned short sc;	/* Control and status info */
+	unsigned short queue_id;
+};
+
+#define AVB_WAKE_THREAD    (1 << 0)
+#define AVB_WAKE_NAPI      (1 << 1)
+
+#define AVB_TX_FLAG_SKB		(1 << 0)
+#define AVB_TX_FLAG_HW_TS 	(1 << 1)
+#define AVB_TX_FLAG_HW_CSUM 	(1 << 2)
+#define AVB_TX_FLAG_TS	 	(1 << 3)
+
+struct avb_ops {
+	void (*open)(void *, void *, int);
+	void (*close)(void *);
+
+	void * (*alloc)(void *);
+	void (*free)(void *, struct avb_desc *);
+
+	int (*rx)(void *, struct avb_rx_desc *);
+	void * (*dequeue)(void *);
+
+	int (*tx)(void *, struct avb_tx_desc *);
+	int (*tx_full)(void *);
+
+	int (*tx_cleanup)(void *, struct avb_tx_desc *);
+	int (*tx_cleanup_ready)(void *);
+	void * (*tx_cleanup_dequeue)(void *);
+
+	int (*tx_ts)(void *, struct avb_desc *);
+
+	struct module *owner;
+};
+
+#define TX_QUEUE_FLAGS_STRICT_PRIORITY	BIT(0)
+#define TX_QUEUE_FLAGS_CREDIT_SHAPER	BIT(1)
+
+#define TX_QUEUE_PROP_MAX		8
+
+struct tx_queue_property {
+	unsigned int priority;
+	unsigned int flags;
+};
+
+struct tx_queue_properties {
+	int num_queues;
+	struct tx_queue_property queue[TX_QUEUE_PROP_MAX];
+};
+
+int fec_enet_get_tx_queue_properties(int ifindex, struct tx_queue_properties *prop);
+int fec_enet_set_idle_slope(void *data, unsigned int queue_id, u32 idle_slope);
+int fec_enet_avb_register(const char *ifname, const struct avb_ops *avb, void *data);
+struct device *fec_enet_avb_get_device(const char *ifname);
+int fec_enet_avb_unregister(int ifindex, const struct avb_ops *avb);
+int fec_enet_rx_poll_avb(void *data);
+int fec_enet_start_xmit_avb(void *data, struct avb_tx_desc *desc);
+void fec_enet_finish_xmit_avb(void *data, unsigned int queue_id);
+int fec_enet_tx_avb(void *data);
+
+int fec_ptp_read_cnt(void *data, u32 *cnt);
+int fec_ptp_tc_start(void *data, u8 id, u32 ts_0, u32 ts_1, u32 tcsr_val);
+void fec_ptp_tc_stop(void *data, u8 id);
+int fec_ptp_tc_reload(void *data, u8 id, u32 ts);
+
+#endif
+
 #endif
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 3dc9bfa8658d..abc4c5117da3 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1,4 +1,5 @@
 /* Copyright 2008-2012 Freescale Semiconductor, Inc.
+ * Copyright 2019-2023 NXP
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -2120,6 +2121,9 @@ const cpumask_t *qman_affine_cpus(void);
  * member of the mask returned from qman_affine_cpus().
  */
 u16 qman_affine_channel(int cpu);
+#ifdef CONFIG_FSL_DPAA_ETHERCAT
+u16 qman_affine_channel_ethercat(int cpu);
+#endif
 
 /**
  * qman_get_affine_portal - return the portal pointer affine to cpu
@@ -2127,6 +2131,10 @@ u16 qman_affine_channel(int cpu);
  *
  */
 void *qman_get_affine_portal(int cpu);
+#ifdef CONFIG_FSL_DPAA_ETHERCAT
+void *qman_get_affine_portal_ethercat(int cpu);
+u32 qman_get_affine_last_cpu(void);
+#endif
 
 /**
  * qman_poll_dqrr - process DQRR (fast-path) entries
diff --git a/include/linux/interrupt.h b/include/linux/interrupt.h
index a92bce40b04b..bf82980f569d 100644
--- a/include/linux/interrupt.h
+++ b/include/linux/interrupt.h
@@ -605,6 +605,35 @@ extern void __raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq_irqoff(unsigned int nr);
 extern void raise_softirq(unsigned int nr);
 
+#ifdef CONFIG_PREEMPT_RT
+DECLARE_PER_CPU(struct task_struct *, timersd);
+DECLARE_PER_CPU(unsigned long, pending_timer_softirq);
+
+extern void raise_timer_softirq(void);
+extern void raise_hrtimer_softirq(void);
+
+static inline unsigned int local_pending_timers(void)
+{
+        return __this_cpu_read(pending_timer_softirq);
+}
+
+#else
+static inline void raise_timer_softirq(void)
+{
+	raise_softirq(TIMER_SOFTIRQ);
+}
+
+static inline void raise_hrtimer_softirq(void)
+{
+	raise_softirq_irqoff(HRTIMER_SOFTIRQ);
+}
+
+static inline unsigned int local_pending_timers(void)
+{
+        return local_softirq_pending();
+}
+#endif
+
 DECLARE_PER_CPU(struct task_struct *, ksoftirqd);
 
 static inline struct task_struct *this_cpu_ksoftirqd(void)
diff --git a/include/linux/ipi_baremetal.h b/include/linux/ipi_baremetal.h
new file mode 100644
index 000000000000..5f124be40dcc
--- /dev/null
+++ b/include/linux/ipi_baremetal.h
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * include/linux/ipi_baremetal.h
+ *
+ * Copyright 2018-2023 NXP
+ *
+ */
+
+#ifndef __LINUX_IPI_BAREMETAL_H
+#define __LINUX_IPI_BAREMETAL_H
+
+#include <linux/kernel.h>
+
+#if defined(CONFIG_LS1021A_BAREMETAL) || \
+    defined(CONFIG_LS1028A_BAREMETAL) || \
+    defined(CONFIG_IMX93_BAREMETAL)
+#define CONFIG_MAX_CPUS 2
+#elif defined(CONFIG_IMX8M_BAREMETAL)
+#define CONFIG_MAX_CPUS 4
+#elif defined(CONFIG_LX2160A_BAREMETAL)
+#define CONFIG_MAX_CPUS 16
+#else
+#define CONFIG_MAX_CPUS 4
+#endif
+
+int ipi_baremetal_handle(u32 irqnr, u32 irqsrc);
+#endif	/* !__LINUX_IPI_BAREMETAL_H */
diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h
index 1f1099dac3f0..1023f349af71 100644
--- a/include/linux/lockdep.h
+++ b/include/linux/lockdep.h
@@ -435,7 +435,6 @@ enum xhlock_context_t {
 	XHLOCK_CTX_NR,
 };
 
-#define lockdep_init_map_crosslock(m, n, k, s) do {} while (0)
 /*
  * To initialize a lockdep_map statically use this macro.
  * Note that _name must not be NULL.
diff --git a/include/linux/net.h b/include/linux/net.h
index 18d942bbdf6e..38f9d5318f58 100644
--- a/include/linux/net.h
+++ b/include/linux/net.h
@@ -124,6 +124,8 @@ struct socket {
 	const struct proto_ops	*ops;
 
 	struct socket_wq	wq;
+
+	struct net_device *ndev;
 };
 
 /*
diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h
index 5a04fbf72476..980f2d75a6d2 100644
--- a/include/linux/netdevice.h
+++ b/include/linux/netdevice.h
@@ -338,6 +338,8 @@ struct gro_list {
  */
 #define GRO_HASH_BUCKETS	8
 
+
+#define NAPINAMSIZ		8
 /*
  * Structure for NAPI scheduling similar to tasklet but with weighting
  */
@@ -368,6 +370,7 @@ struct napi_struct {
 	struct hlist_node	napi_hash_node;
 	unsigned int		napi_id;
 	struct task_struct	*thread;
+	char			name[NAPINAMSIZ];
 };
 
 enum {
@@ -1404,6 +1407,9 @@ struct net_device_ops {
 	int			(*ndo_stop)(struct net_device *dev);
 	netdev_tx_t		(*ndo_start_xmit)(struct sk_buff *skb,
 						  struct net_device *dev);
+	struct sk_buff* 	(*ndo_start_recv)(struct net_device *dev, int *err);
+	int			(*ndo_fast_recv)(struct net_device *ndev, void __user *buff, size_t len, struct sockaddr __user *addr,  int __user *addr_len);
+	int			(*ndo_fast_xmit)(struct net_device *ndev, void __user *buff, size_t len);
 	netdev_features_t	(*ndo_features_check)(struct sk_buff *skb,
 						      struct net_device *dev,
 						      netdev_features_t features);
@@ -2027,6 +2033,8 @@ struct net_device {
 	unsigned long		mem_start;
 	unsigned long		base_addr;
 
+	unsigned int		fast_raw_device;
+
 	/*
 	 *	Some hardware also needs these fields (state,dev_list,
 	 *	napi_list,unreg_list,close_list) but they are not
@@ -2532,6 +2540,21 @@ void dev_net_set(struct net_device *dev, struct net *net)
 	write_pnet(&dev->nd_net, net);
 }
 
+/**
+ *	netif_napi_add_named - initialize a NAPI context
+ *	@dev:  network device
+ *	@napi: NAPI context
+ *	@poll: polling function
+ *	@weight: default weight
+ *	@name: napi instance name
+ *
+ * netif_napi_add_named() must be used to initialize a NAPI context prior to calling
+ * *any* of the other NAPI-related functions.
+ */
+void netif_napi_add_named(struct net_device *dev, struct napi_struct *napi,
+		    int (*poll)(struct napi_struct *, int), int weight,
+		    const char *name);
+
 /**
  *	netdev_priv - access network device private data
  *	@dev: network device
@@ -2605,6 +2628,27 @@ static inline void netif_napi_add_tx(struct net_device *dev,
 	netif_napi_add_tx_weight(dev, napi, poll, NAPI_POLL_WEIGHT);
 }
 
+/**
+ *	netif_napi_add_tx_named - initialize a NAPI context
+ *	@dev:  network device
+ *	@napi: NAPI context
+ *	@poll: polling function
+ *	@weight: default weight
+ *	@name: napi instance name
+ *
+ * This variant of netif_napi_add_named() should be used from drivers using NAPI
+ * to exclusively poll a TX queue.
+ * This will avoid we add it into napi_hash[], thus polluting this hash table.
+ */
+static inline void netif_napi_add_tx_named(struct net_device *dev,
+					   struct napi_struct *napi,
+					   int (*poll)(struct napi_struct *, int),
+					   int weight, const char *name)
+{
+	set_bit(NAPI_STATE_NO_BUSY_POLL, &napi->state);
+	netif_napi_add_named(dev, napi, poll, weight, name);
+}
+
 /**
  *  __netif_napi_del - remove a NAPI context
  *  @napi: NAPI context
@@ -3169,7 +3213,11 @@ struct softnet_data {
 	int			defer_count;
 	int			defer_ipi_scheduled;
 	struct sk_buff		*defer_list;
+#ifndef CONFIG_PREEMPT_RT
 	call_single_data_t	defer_csd;
+#else
+	struct work_struct	defer_work;
+#endif
 };
 
 static inline void input_queue_head_incr(struct softnet_data *sd)
diff --git a/include/linux/preempt.h b/include/linux/preempt.h
index 0df425bf9bd7..12f59cdaaedd 100644
--- a/include/linux/preempt.h
+++ b/include/linux/preempt.h
@@ -196,6 +196,20 @@ extern void preempt_count_sub(int val);
 #define preempt_count_inc() preempt_count_add(1)
 #define preempt_count_dec() preempt_count_sub(1)
 
+#ifdef CONFIG_PREEMPT_LAZY
+#define add_preempt_lazy_count(val)	do { preempt_lazy_count() += (val); } while (0)
+#define sub_preempt_lazy_count(val)	do { preempt_lazy_count() -= (val); } while (0)
+#define inc_preempt_lazy_count()	add_preempt_lazy_count(1)
+#define dec_preempt_lazy_count()	sub_preempt_lazy_count(1)
+#define preempt_lazy_count()		(current_thread_info()->preempt_lazy_count)
+#else
+#define add_preempt_lazy_count(val)	do { } while (0)
+#define sub_preempt_lazy_count(val)	do { } while (0)
+#define inc_preempt_lazy_count()	do { } while (0)
+#define dec_preempt_lazy_count()	do { } while (0)
+#define preempt_lazy_count()		(0)
+#endif
+
 #ifdef CONFIG_PREEMPT_COUNT
 
 #define preempt_disable() \
@@ -204,6 +218,12 @@ do { \
 	barrier(); \
 } while (0)
 
+#define preempt_lazy_disable() \
+do { \
+	inc_preempt_lazy_count(); \
+	barrier(); \
+} while (0)
+
 #define sched_preempt_enable_no_resched() \
 do { \
 	barrier(); \
@@ -235,6 +255,18 @@ do { \
 		__preempt_schedule(); \
 } while (0)
 
+/*
+ * open code preempt_check_resched() because it is not exported to modules and
+ * used by local_unlock() or bpf_enable_instrumentation().
+ */
+#define preempt_lazy_enable() \
+do { \
+	dec_preempt_lazy_count(); \
+	barrier(); \
+	if (should_resched(0)) \
+		__preempt_schedule(); \
+} while (0)
+
 #else /* !CONFIG_PREEMPTION */
 #define preempt_enable() \
 do { \
@@ -242,6 +274,12 @@ do { \
 	preempt_count_dec(); \
 } while (0)
 
+#define preempt_lazy_enable() \
+do { \
+	dec_preempt_lazy_count(); \
+	barrier(); \
+} while (0)
+
 #define preempt_enable_notrace() \
 do { \
 	barrier(); \
@@ -282,6 +320,9 @@ do { \
 #define preempt_enable_notrace()		barrier()
 #define preemptible()				0
 
+#define preempt_lazy_disable()			barrier()
+#define preempt_lazy_enable()			barrier()
+
 #endif /* CONFIG_PREEMPT_COUNT */
 
 #ifdef MODULE
@@ -300,7 +341,7 @@ do { \
 } while (0)
 #define preempt_fold_need_resched() \
 do { \
-	if (tif_need_resched()) \
+	if (tif_need_resched_now()) \
 		set_preempt_need_resched(); \
 } while (0)
 
@@ -416,8 +457,15 @@ extern void migrate_enable(void);
 
 #else
 
-static inline void migrate_disable(void) { }
-static inline void migrate_enable(void) { }
+static inline void migrate_disable(void)
+{
+	preempt_lazy_disable();
+}
+
+static inline void migrate_enable(void)
+{
+	preempt_lazy_enable();
+}
 
 #endif /* CONFIG_SMP */
 
diff --git a/include/linux/printk.h b/include/linux/printk.h
index 8c81806c2e99..f8c4e4fa6d7d 100644
--- a/include/linux/printk.h
+++ b/include/linux/printk.h
@@ -168,6 +168,9 @@ extern void __printk_safe_exit(void);
  */
 #define printk_deferred_enter __printk_safe_enter
 #define printk_deferred_exit __printk_safe_exit
+extern void printk_prefer_direct_enter(void);
+extern void printk_prefer_direct_exit(void);
+extern void try_block_console_kthreads(int timeout_ms);
 
 /*
  * Please don't use printk_ratelimit(), because it shares ratelimiting state
@@ -219,6 +222,18 @@ static inline void printk_deferred_exit(void)
 {
 }
 
+static inline void printk_prefer_direct_enter(void)
+{
+}
+
+static inline void printk_prefer_direct_exit(void)
+{
+}
+
+static inline void try_block_console_kthreads(int timeout_ms)
+{
+}
+
 static inline int printk_ratelimit(void)
 {
 	return 0;
diff --git a/include/linux/rpmsg/imx_srtm.h b/include/linux/rpmsg/imx_srtm.h
new file mode 100644
index 000000000000..7c0c53916cce
--- /dev/null
+++ b/include/linux/rpmsg/imx_srtm.h
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright 2022-2023 NXP
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/*
+ * @file linux/rpmsg/imx_srtm.h
+ *
+ * @brief Global header file for iMX SRTM (Simplified Real Time Message Application Protocol, base on rpmsg)
+ *
+ * @ingroup SRTM
+ */
+#ifndef __LINUX_RPMSG_IMX_SRTM_H__
+#define __LINUX_RPMSG_IMX_SRTM_H__
+
+/* Category define */
+#define IMX_SRTM_CATEGORY_LIFECYCLE	(0x1)
+#define IMX_SRTM_CATEGORY_PMIC		(0x2)
+#define IMX_SRTM_CATEGORY_AUDIO		(0x3)
+#define IMX_SRTM_CATEGORY_KEY		(0x4)
+#define IMX_SRTM_CATEGORY_GPIO		(0x5)
+#define IMX_SRTM_CATEGORY_RTC		(0x6)
+#define IMX_SRTM_CATEGORY_SENSOR	(0x7)
+#define IMX_SRTM_CATEGORY_AUTO		(0x8)
+#define IMX_SRTM_CATEGORY_I2C		(0x9)
+#define IMX_SRTM_CATEGORY_PWM		(0xA)
+#define IMX_SRTM_CATEGORY_UART		(0xB)
+
+/* srtm version */
+#define IMX_SRTM_VER_UART (0x0001)
+
+/* type */
+#define IMX_SRTM_TYPE_REQUEST (0)
+#define IMX_SRTM_TYPE_RESPONSE (1)
+#define IMX_SRTM_TYPE_NOTIFY (2)
+
+/* command */
+#define IMX_SRTM_UART_COMMAND_SEND (1)
+#define IMX_SRTM_UART_COMMAND_HELLO (2)
+
+/* priority */
+#define IMX_SRTM_UART_PRIORITY	(0x01)
+
+/* flags */
+#define IMX_SRTM_RPMSG_OVER_UART_FLAG (1 << 0)
+#define IMX_SRTM_UART_SUPPORT_MULTI_UART_MSG_FLAG (1 << 1)
+#define IMX_SRTM_UART_PORT_NUM_SHIFT (11U)
+#define IMX_SRTM_UART_PORT_NUM_MASK (0x1F << 11U)
+#define IMX_SRTM_UART_SPECIFY_PORT_NUM_SHIFT (10U)
+#define IMX_SRTM_UART_SPECIFY_PORT_NUM_MASK (1 << IMX_SRTM_UART_SPECIFY_PORT_NUM_SHIFT)
+
+struct imx_srtm_head {
+	u8 cate;
+	u8 major;
+	u8 minor;
+	u8 type;
+	u8 cmd;
+	u8 reserved[5];
+} __packed;
+
+#endif /* __LINUX_RPMSG_IMX_SRTM_H__ */
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 0cac69902ec5..67ec36dbfacf 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -2061,6 +2061,43 @@ static inline int test_tsk_need_resched(struct task_struct *tsk)
 	return unlikely(test_tsk_thread_flag(tsk,TIF_NEED_RESCHED));
 }
 
+#ifdef CONFIG_PREEMPT_LAZY
+static inline void set_tsk_need_resched_lazy(struct task_struct *tsk)
+{
+	set_tsk_thread_flag(tsk,TIF_NEED_RESCHED_LAZY);
+}
+
+static inline void clear_tsk_need_resched_lazy(struct task_struct *tsk)
+{
+	clear_tsk_thread_flag(tsk,TIF_NEED_RESCHED_LAZY);
+}
+
+static inline int test_tsk_need_resched_lazy(struct task_struct *tsk)
+{
+	return unlikely(test_tsk_thread_flag(tsk,TIF_NEED_RESCHED_LAZY));
+}
+
+static inline int need_resched_lazy(void)
+{
+	return test_thread_flag(TIF_NEED_RESCHED_LAZY);
+}
+
+static inline int need_resched_now(void)
+{
+	return test_thread_flag(TIF_NEED_RESCHED);
+}
+
+#else
+static inline void clear_tsk_need_resched_lazy(struct task_struct *tsk) { }
+static inline int need_resched_lazy(void) { return 0; }
+
+static inline int need_resched_now(void)
+{
+	return test_thread_flag(TIF_NEED_RESCHED);
+}
+
+#endif
+
 /*
  * cond_resched() and cond_resched_lock(): latency reduction via
  * explicit rescheduling in places that are safe. The return
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index 79b328861c5f..35f44352e641 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -7,6 +7,7 @@
 #ifndef _LINUX_SERIAL_8250_H
 #define _LINUX_SERIAL_8250_H
 
+#include <linux/atomic.h>
 #include <linux/serial_core.h>
 #include <linux/serial_reg.h>
 #include <linux/platform_device.h>
@@ -124,6 +125,8 @@ struct uart_8250_port {
 #define MSR_SAVE_FLAGS UART_MSR_ANY_DELTA
 	unsigned char		msr_saved_flags;
 
+	atomic_t		console_printing;
+
 	struct uart_8250_dma	*dma;
 	const struct uart_8250_ops *ops;
 
@@ -179,6 +182,8 @@ void serial8250_init_port(struct uart_8250_port *up);
 void serial8250_set_defaults(struct uart_8250_port *up);
 void serial8250_console_write(struct uart_8250_port *up, const char *s,
 			      unsigned int count);
+void serial8250_console_write_atomic(struct uart_8250_port *up, const char *s,
+				     unsigned int count);
 int serial8250_console_setup(struct uart_port *port, char *options, bool probe);
 int serial8250_console_exit(struct uart_port *port);
 
diff --git a/include/linux/thread_info.h b/include/linux/thread_info.h
index 9f392ec76f2b..779e0e96b9cb 100644
--- a/include/linux/thread_info.h
+++ b/include/linux/thread_info.h
@@ -177,7 +177,17 @@ static __always_inline unsigned long read_ti_thread_flags(struct thread_info *ti
 	clear_ti_thread_flag(task_thread_info(t), TIF_##fl)
 #endif /* !CONFIG_GENERIC_ENTRY */
 
-#define tif_need_resched() test_thread_flag(TIF_NEED_RESCHED)
+#ifdef CONFIG_PREEMPT_LAZY
+#define tif_need_resched()	(test_thread_flag(TIF_NEED_RESCHED) || \
+				 test_thread_flag(TIF_NEED_RESCHED_LAZY))
+#define tif_need_resched_now()	(test_thread_flag(TIF_NEED_RESCHED))
+#define tif_need_resched_lazy()	test_thread_flag(TIF_NEED_RESCHED_LAZY)
+
+#else
+#define tif_need_resched()	test_thread_flag(TIF_NEED_RESCHED)
+#define tif_need_resched_now()	test_thread_flag(TIF_NEED_RESCHED)
+#define tif_need_resched_lazy()	0
+#endif
 
 #ifndef CONFIG_HAVE_ARCH_WITHIN_STACK_FRAMES
 static inline int arch_within_stack_frames(const void * const stack,
diff --git a/include/linux/trace_events.h b/include/linux/trace_events.h
index 422f4ca656cf..da13c633d1d8 100644
--- a/include/linux/trace_events.h
+++ b/include/linux/trace_events.h
@@ -70,6 +70,7 @@ struct trace_entry {
 	unsigned char		flags;
 	unsigned char		preempt_count;
 	int			pid;
+	unsigned char		preempt_lazy_count;
 };
 
 #define TRACE_EVENT_TYPE_MAX						\
@@ -159,9 +160,10 @@ static inline void tracing_generic_entry_update(struct trace_entry *entry,
 						unsigned int trace_ctx)
 {
 	entry->preempt_count		= trace_ctx & 0xff;
+	entry->preempt_lazy_count	= (trace_ctx >> 16) & 0xff;
 	entry->pid			= current->pid;
 	entry->type			= type;
-	entry->flags =			trace_ctx >> 16;
+	entry->flags			= trace_ctx >> 24;
 }
 
 unsigned int tracing_gen_ctx_irq_test(unsigned int irqs_status);
@@ -172,7 +174,13 @@ enum trace_flag_type {
 	TRACE_FLAG_NEED_RESCHED		= 0x04,
 	TRACE_FLAG_HARDIRQ		= 0x08,
 	TRACE_FLAG_SOFTIRQ		= 0x10,
+#ifdef CONFIG_PREEMPT_LAZY
+	TRACE_FLAG_PREEMPT_RESCHED	= 0x00,
+	TRACE_FLAG_NEED_RESCHED_LAZY	= 0x20,
+#else
+	TRACE_FLAG_NEED_RESCHED_LAZY	= 0x00,
 	TRACE_FLAG_PREEMPT_RESCHED	= 0x20,
+#endif
 	TRACE_FLAG_NMI			= 0x40,
 	TRACE_FLAG_BH_OFF		= 0x80,
 };
diff --git a/include/linux/u64_stats_sync.h b/include/linux/u64_stats_sync.h
index 46040d66334a..ffe48e69b3f3 100644
--- a/include/linux/u64_stats_sync.h
+++ b/include/linux/u64_stats_sync.h
@@ -213,16 +213,4 @@ static inline bool u64_stats_fetch_retry(const struct u64_stats_sync *syncp,
 	return __u64_stats_fetch_retry(syncp, start);
 }
 
-/* Obsolete interfaces */
-static inline unsigned int u64_stats_fetch_begin_irq(const struct u64_stats_sync *syncp)
-{
-	return u64_stats_fetch_begin(syncp);
-}
-
-static inline bool u64_stats_fetch_retry_irq(const struct u64_stats_sync *syncp,
-					     unsigned int start)
-{
-	return u64_stats_fetch_retry(syncp, start);
-}
-
 #endif /* _LINUX_U64_STATS_SYNC_H */
diff --git a/include/net/dsa.h b/include/net/dsa.h
index 765b6a6d98da..71772299cdf0 100644
--- a/include/net/dsa.h
+++ b/include/net/dsa.h
@@ -55,6 +55,7 @@ struct phylink_link_state;
 #define DSA_TAG_PROTO_RTL8_4T_VALUE		25
 #define DSA_TAG_PROTO_RZN1_A5PSW_VALUE		26
 #define DSA_TAG_PROTO_LAN937X_VALUE		27
+#define DSA_TAG_PROTO_NETC_VALUE		28
 
 enum dsa_tag_protocol {
 	DSA_TAG_PROTO_NONE		= DSA_TAG_PROTO_NONE_VALUE,
@@ -85,6 +86,7 @@ enum dsa_tag_protocol {
 	DSA_TAG_PROTO_RTL8_4T		= DSA_TAG_PROTO_RTL8_4T_VALUE,
 	DSA_TAG_PROTO_RZN1_A5PSW	= DSA_TAG_PROTO_RZN1_A5PSW_VALUE,
 	DSA_TAG_PROTO_LAN937X		= DSA_TAG_PROTO_LAN937X_VALUE,
+	DSA_TAG_PROTO_NETC		= DSA_TAG_PROTO_NETC_VALUE,
 };
 
 struct dsa_switch;
@@ -961,6 +963,22 @@ struct dsa_switch_ops {
 	int	(*port_del_dscp_prio)(struct dsa_switch *ds, int port, u8 dscp,
 				      u8 prio);
 
+	/*
+	 * ethtool --set-frame-preemption
+	 */
+	int	(*set_preempt)(struct dsa_switch *ds, int port,
+			       struct ethtool_fp *fpcmd);
+
+	/*
+	 * ethtool --show-frame-preemption
+	 */
+	int	(*get_preempt)(struct dsa_switch *ds, int port,
+			       struct ethtool_fp *fpcmd);
+
+	/*
+	 * ethtool --reset-frame-preemption
+	 */
+	int	(*reset_preempt)(struct dsa_switch *ds, int port, bool enable);
 	/*
 	 * Suspend and resume
 	 */
diff --git a/include/net/pkt_cls.h b/include/net/pkt_cls.h
index 4cabb32a2ad9..cd410a87517b 100644
--- a/include/net/pkt_cls.h
+++ b/include/net/pkt_cls.h
@@ -788,16 +788,6 @@ struct tc_cls_bpf_offload {
 	bool exts_integrated;
 };
 
-struct tc_mqprio_qopt_offload {
-	/* struct tc_mqprio_qopt must always be the first element */
-	struct tc_mqprio_qopt qopt;
-	u16 mode;
-	u16 shaper;
-	u32 flags;
-	u64 min_rate[TC_QOPT_MAX_QUEUE];
-	u64 max_rate[TC_QOPT_MAX_QUEUE];
-};
-
 /* This structure holds cookie structure that is passed from user
  * to the kernel for actions and classifiers
  */
diff --git a/include/net/pkt_sched.h b/include/net/pkt_sched.h
index fa9a8df3fa76..822c8b5587ec 100644
--- a/include/net/pkt_sched.h
+++ b/include/net/pkt_sched.h
@@ -162,6 +162,16 @@ struct tc_etf_qopt_offload {
 	s32 queue;
 };
 
+struct tc_mqprio_qopt_offload {
+	/* struct tc_mqprio_qopt must always be the first element */
+	struct tc_mqprio_qopt qopt;
+	u16 mode;
+	u16 shaper;
+	u32 flags;
+	u64 min_rate[TC_QOPT_MAX_QUEUE];
+	u64 max_rate[TC_QOPT_MAX_QUEUE];
+};
+
 struct tc_taprio_caps {
 	bool supports_queue_max_sdu:1;
 };
@@ -175,6 +185,7 @@ struct tc_taprio_sched_entry {
 };
 
 struct tc_taprio_qopt_offload {
+	struct tc_mqprio_qopt_offload mqprio;
 	u8 enable;
 	ktime_t base_time;
 	u64 cycle_time;
diff --git a/include/net/switchdev.h b/include/net/switchdev.h
index 7dcdc97c0bc3..5b6a4ce1f47c 100644
--- a/include/net/switchdev.h
+++ b/include/net/switchdev.h
@@ -97,6 +97,7 @@ struct switchdev_obj_port_vlan {
 	struct switchdev_obj obj;
 	u16 flags;
 	u16 vid;
+	u16 proto;
 	/* If set, the notifier signifies a change of one of the following
 	 * flags for a VLAN that already exists:
 	 * - BRIDGE_VLAN_INFO_PVID
diff --git a/include/soc/mscc/ocelot.h b/include/soc/mscc/ocelot.h
index ca9ed16b6140..831587238e3f 100644
--- a/include/soc/mscc/ocelot.h
+++ b/include/soc/mscc/ocelot.h
@@ -1044,6 +1044,7 @@ struct ocelot_port {
 
 	u8				stp_state;
 	bool				vlan_aware;
+	bool				qinq_mode;
 	bool				is_dsa_8021q_cpu;
 	bool				learn_ena;
 
@@ -1054,6 +1055,7 @@ struct ocelot_port {
 	bool				force_forward;
 	u8				cut_thru;
 	u8				preemptable_prios;
+	bool				fp_enabled_admin;
 
 	int				speed;
 };
@@ -1139,6 +1141,9 @@ struct ocelot {
 	spinlock_t			ptp_clock_lock;
 	struct ptp_pin_desc		ptp_pins[OCELOT_PTP_PINS_NUM];
 
+	bool				qinq_enable;
+	struct kref			qinq_refcount;
+
 	struct ocelot_fdma		*fdma;
 };
 
diff --git a/include/soc/mscc/ocelot_vcap.h b/include/soc/mscc/ocelot_vcap.h
index c601a4598b0d..f8cde2408890 100644
--- a/include/soc/mscc/ocelot_vcap.h
+++ b/include/soc/mscc/ocelot_vcap.h
@@ -704,6 +704,7 @@ struct ocelot_vcap_filter {
 	enum ocelot_vcap_bit dmac_mc;
 	enum ocelot_vcap_bit dmac_bc;
 	struct ocelot_vcap_key_vlan vlan;
+	struct ocelot_vcap_key_vlan cvlan;
 
 	enum ocelot_vcap_key_type key_type;
 	union {
diff --git a/include/uapi/linux/ethtool.h b/include/uapi/linux/ethtool.h
index dc2aa3d75b39..b662a48658dc 100644
--- a/include/uapi/linux/ethtool.h
+++ b/include/uapi/linux/ethtool.h
@@ -381,6 +381,32 @@ struct ethtool_eee {
 	__u32	reserved[2];
 };
 
+/**
+ * struct ethtool_fp - Frame Preemption information
+ * @cmd: ETHTOOL_{G,S}FP
+ * @disabled: Disable hardware preemption supports.
+ * @fp_supported: If frame preemption is supported.
+ * @fp_enabled: If frame preemption should be advertised to the link partner
+ *	as enabled.
+ * @supported_queues_mask: Bitmask indicating which queues support being
+ *	configured as preemptible (bit 0 -> queue 0, bit N -> queue N).
+ * @preemptible_queues_mask: Bitmask indicating which queues are
+ *	configured as preemptible (bit 0 -> queue 0, bit N -> queue N).
+ * @min_frag_size: Minimum size for all non-final fragment size.
+ */
+struct ethtool_fp {
+	__u32	cmd;
+	__u8	disabled;
+	__u8	fp_supported;
+	__u8	fp_enabled;
+	__u8    fp_status;
+	__u8    fp_active;
+	__u32	supported_queues_mask;
+	__u32	preemptible_queues_mask;
+	__u32	min_frag_size;
+	__u32	reserved[2];
+};
+
 /**
  * struct ethtool_modinfo - plugin module eeprom information
  * @cmd: %ETHTOOL_GMODULEINFO
@@ -1630,6 +1656,10 @@ enum ethtool_fec_config_bits {
 #define ETHTOOL_GFECPARAM	0x00000050 /* Get FEC settings */
 #define ETHTOOL_SFECPARAM	0x00000051 /* Set FEC settings */
 
+#define ETHTOOL_GFP		0x00000052 /* Get Frame Preemption settings */
+#define ETHTOOL_SFP		0x00000053 /* Set Frame Preemption settings */
+#define ETHTOOL_RFP            0x00000054 /* Reset Frame Preemption settings */
+
 /* compatibility with older code */
 #define SPARC_ETH_GSET		ETHTOOL_GSET
 #define SPARC_ETH_SSET		ETHTOOL_SSET
diff --git a/include/uapi/linux/ethtool_netlink.h b/include/uapi/linux/ethtool_netlink.h
index 69f5bec347c2..47650669c3c1 100644
--- a/include/uapi/linux/ethtool_netlink.h
+++ b/include/uapi/linux/ethtool_netlink.h
@@ -41,6 +41,8 @@ enum {
 	ETHTOOL_MSG_TSINFO_GET,
 	ETHTOOL_MSG_CABLE_TEST_ACT,
 	ETHTOOL_MSG_CABLE_TEST_TDR_ACT,
+	ETHTOOL_MSG_PREEMPT_GET,
+	ETHTOOL_MSG_PREEMPT_SET,
 	ETHTOOL_MSG_TUNNEL_INFO_GET,
 	ETHTOOL_MSG_FEC_GET,
 	ETHTOOL_MSG_FEC_SET,
@@ -88,6 +90,8 @@ enum {
 	ETHTOOL_MSG_TSINFO_GET_REPLY,
 	ETHTOOL_MSG_CABLE_TEST_NTF,
 	ETHTOOL_MSG_CABLE_TEST_TDR_NTF,
+	ETHTOOL_MSG_PREEMPT_GET_REPLY,
+	ETHTOOL_MSG_PREEMPT_NTF,
 	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY,
 	ETHTOOL_MSG_FEC_GET_REPLY,
 	ETHTOOL_MSG_FEC_NTF,
@@ -879,6 +883,23 @@ enum {
 	ETHTOOL_A_PSE_MAX = (__ETHTOOL_A_PSE_CNT - 1)
 };
 
+/* FRAME PREEMPTION */
+enum {
+	ETHTOOL_A_PREEMPT_UNSPEC,
+	ETHTOOL_A_PREEMPT_HEADER,			/* nest - _A_HEADER_* */
+	ETHTOOL_A_PREEMPT_DISABLED,			/* bool */
+	ETHTOOL_A_PREEMPT_SUPPORTED,			/* u8 */
+	ETHTOOL_A_PREEMPT_STATUS,			/* u8 */
+	ETHTOOL_A_PREEMPT_ACTIVE,			/* u8 */
+	ETHTOOL_A_PREEMPT_MIN_FRAG_SIZE,		/* u32 */
+	ETHTOOL_A_PREEMPT_QUEUES_SUPPORTED,		/* u32 */
+	ETHTOOL_A_PREEMPT_QUEUES_PREEMPTIBLE,		/* u32 */
+
+	/* add new constants above here */
+	__ETHTOOL_A_PREEMPT_CNT,
+	ETHTOOL_A_PREEMPT_MAX = (__ETHTOOL_A_PREEMPT_CNT - 1)
+};
+
 /* generic netlink info */
 #define ETHTOOL_GENL_NAME "ethtool"
 #define ETHTOOL_GENL_VERSION 1
diff --git a/include/uapi/linux/virtio_ids.h b/include/uapi/linux/virtio_ids.h
index 7aa2eb766205..67f7fe400730 100644
--- a/include/uapi/linux/virtio_ids.h
+++ b/include/uapi/linux/virtio_ids.h
@@ -68,6 +68,7 @@
 #define VIRTIO_ID_AUDIO_POLICY		39 /* virtio audio policy */
 #define VIRTIO_ID_BT			40 /* virtio bluetooth */
 #define VIRTIO_ID_GPIO			41 /* virtio gpio */
+#define VIRTIO_ID_TRANS			42 /* virtio transfer test */
 
 /*
  * Virtio Transitional IDs
diff --git a/include/uapi/linux/virtio_mmio.h b/include/uapi/linux/virtio_mmio.h
index 0650f91bea6c..ee672e1b4a6e 100644
--- a/include/uapi/linux/virtio_mmio.h
+++ b/include/uapi/linux/virtio_mmio.h
@@ -110,6 +110,9 @@
 /* Device status register - Read Write */
 #define VIRTIO_MMIO_STATUS		0x070
 
+/* Hypervisor-less virtio: Device write operation done status register */
+#define VIRTIO_MMIO_WD_STATUS		0x074
+
 /* Selected queue's Descriptor Table address, 64 bits in two halves */
 #define VIRTIO_MMIO_QUEUE_DESC_LOW	0x080
 #define VIRTIO_MMIO_QUEUE_DESC_HIGH	0x084
@@ -140,7 +143,9 @@
  * the per-driver configuration space - Read Write */
 #define VIRTIO_MMIO_CONFIG		0x100
 
-
+/* Hypervisor-less virtio: write operation space shared with remote */
+#define VIRTIO_MMIO_RW_OPS_MEM_OFFSET	0x400
+#define VIRTIO_MMIO_RW_OPS_MEM_SIZE	64
 
 /*
  * Interrupt flags (re: interrupt status & acknowledge registers)
diff --git a/include/uapi/linux/virtio_trans.h b/include/uapi/linux/virtio_trans.h
new file mode 100644
index 000000000000..24a10efb370e
--- /dev/null
+++ b/include/uapi/linux/virtio_trans.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: BSD-3-Clause */
+/*
+ * Copyright 2022 NXP
+ */
+
+#ifndef _LINUX_VIRTIO_TRANS_H
+#define _LINUX_VIRTIO_TRANS_H
+
+#include <linux/types.h>
+
+/*
+ * status:
+ *	bit0: TX ready
+ *	bit1: RX ready
+ * config:
+ *	bit0: TX
+ *	bit1: RX
+ *	bit2: 0: Backend do NOT copy buffer
+ *	      1: Backend do copy buffer
+ *	bit3: 0: Backend interrupt mode
+ *	      1: Backend polling mode
+ *	bit4: 0: Frontend interrupt mode
+ *	      1: Frontend polling mode
+ * control:
+ *	bit0: start transfer
+ *	bit1: reset
+ * pkt_size: packet size in Byte
+ * tx_count: Completed count for TX packet, update by Backend
+ * rx_count: Completed count for RX packet, update by Backend
+ * regression: Packets to test, set by Frontend
+ */
+
+#define VT_STATUS	0x0
+#define VT_CONFIG	0x4
+#define VT_CONTROL	0x8
+#define VT_PKT_SIZE	0xc
+#define VT_TX_COUNT	0x10
+#define VT_RX_COUNT	0x14
+#define VT_REGRESSION	0x18
+
+#define VT_CFG_TX	BIT(0)
+#define VT_CFG_RX	BIT(1)
+#define VT_CFG_COPY	BIT(2)
+#define VT_CFG_B_POLL	BIT(3)
+#define VT_CFG_F_POLL	BIT(4)
+
+#define VT_CTRL_START	BIT(0)
+#define VT_CTRL_RESET	BIT(1)
+
+struct virtio_trans_config {
+	__le32 status;
+	__le32 config;
+	__le32 control;
+	__le32 pkt_size;
+	__le32 tx_count;
+	__le32 rx_count;
+	__le32 regression;
+};
+
+#endif /* _LINUX_VIRTIO_TRANS_H */
-- 
2.34.1

