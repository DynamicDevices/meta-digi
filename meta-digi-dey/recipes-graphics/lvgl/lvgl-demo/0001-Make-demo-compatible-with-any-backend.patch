From: Gabriel Valcazar <gabriel.valcazar@digi.com>
Date: Mon, 6 Nov 2023 13:45:27 +0100
Subject: [PATCH] Make demo compatible with any backend

Apply changes so the demo builds and runs with any of the 4 major backends
(wayland, sdl, drm and fbdev)

Signed-off-by: Gabriel Valcazar <gabriel.valcazar@digi.com>
---
 main.c | 142 +++++++++++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 128 insertions(+), 14 deletions(-)

diff --git a/main.c b/main.c
index 33cd734..bb0248a 100644
--- a/main.c
+++ b/main.c
@@ -1,12 +1,23 @@
 #include "lvgl/lvgl.h"
 #include "lvgl/demos/lv_demos.h"
 #include "lv_drivers/display/fbdev.h"
+#include "lv_drivers/display/drm.h"
 #include "lv_drivers/indev/evdev.h"
+#include "lv_drivers/sdl/sdl.h"
+#include "lv_drivers/wayland/wayland.h"
+
+#if USE_SDL
+#define SDL_MAIN_HANDLED /*To fix SDL's "undefined reference to WinMain" issue*/
+#include <SDL2/SDL.h>
+#endif
+
 #include <unistd.h>
 #include <pthread.h>
 #include <time.h>
 #include <sys/time.h>
 
+static void backend_init(void);
+
 #define DISP_BUF_SIZE (128 * 1024)
 
 int main(void)
@@ -14,8 +25,78 @@ int main(void)
     /*LittlevGL init*/
     lv_init();
 
-    /*Linux frame buffer device init*/
-    fbdev_init();
+    backend_init();
+
+    /*Create a Demo*/
+    lv_demo_widgets();
+
+    /*Handle LitlevGL tasks (tickless mode)*/
+    while(1) {
+        lv_timer_handler();
+        usleep(5000);
+    }
+
+    return 0;
+}
+
+static void backend_init(void)
+{
+#if USE_WAYLAND
+    lv_wayland_init();
+
+    /* Create a display */
+    lv_disp_t * disp = lv_wayland_create_window(800, 480, "lvgl wayland demo", NULL /*close_cb*/);
+#elif USE_SDL
+    sdl_init();
+
+    /*A small buffer for LittlevGL to draw the screen's content*/
+    static lv_color_t buf[SDL_HOR_RES * 100];
+
+    /*Initialize a descriptor for the buffer*/
+    static lv_disp_draw_buf_t disp_buf;
+    lv_disp_draw_buf_init(&disp_buf, buf, NULL, SDL_HOR_RES * 100);
+
+    /*Initialize and register a display driver*/
+    static lv_disp_drv_t disp_drv;
+    lv_disp_drv_init(&disp_drv);
+    disp_drv.draw_buf   = &disp_buf;
+    disp_drv.flush_cb = sdl_display_flush;
+    disp_drv.hor_res    = SDL_HOR_RES;
+    disp_drv.ver_res    = SDL_VER_RES;
+    lv_disp_drv_register(&disp_drv);
+
+    lv_group_t * g = lv_group_create();
+    lv_group_set_default(g);
+
+    static lv_indev_drv_t indev_drv_1;
+    lv_indev_drv_init(&indev_drv_1); /*Basic initialization*/
+    indev_drv_1.type = LV_INDEV_TYPE_POINTER;
+
+    /*This function will be called periodically (by the library) to get the mouse position and state*/
+    indev_drv_1.read_cb = sdl_mouse_read;
+    lv_indev_t *mouse_indev = lv_indev_drv_register(&indev_drv_1);
+
+    /*Set a cursor for the mouse*/
+    LV_IMG_DECLARE(mouse_cursor_icon)
+    lv_obj_t * cursor_obj = lv_img_create(lv_scr_act()); /*Create an image object for the cursor */
+    lv_img_set_src(cursor_obj, &mouse_cursor_icon);           /*Set the image source*/
+    lv_indev_set_cursor(mouse_indev, cursor_obj);             /*Connect the image  object to the driver*/
+
+    static lv_indev_drv_t indev_drv_2;
+    lv_indev_drv_init(&indev_drv_2); /*Basic initialization*/
+    indev_drv_2.type = LV_INDEV_TYPE_KEYPAD;
+    indev_drv_2.read_cb = sdl_keyboard_read;
+    lv_indev_t *kb_indev = lv_indev_drv_register(&indev_drv_2);
+    lv_indev_set_group(kb_indev, g);
+
+    static lv_indev_drv_t indev_drv_3;
+    lv_indev_drv_init(&indev_drv_3); /*Basic initialization*/
+    indev_drv_3.type = LV_INDEV_TYPE_ENCODER;
+    indev_drv_3.read_cb = sdl_mousewheel_read;
+    lv_indev_t * enc_indev = lv_indev_drv_register(&indev_drv_3);
+    lv_indev_set_group(enc_indev, g);
+#elif USE_DRM
+    drm_init();
 
     /*A small buffer for LittlevGL to draw the screen's content*/
     static lv_color_t buf[DISP_BUF_SIZE];
@@ -28,12 +109,20 @@ int main(void)
     static lv_disp_drv_t disp_drv;
     lv_disp_drv_init(&disp_drv);
     disp_drv.draw_buf   = &disp_buf;
-    disp_drv.flush_cb   = fbdev_flush;
-    disp_drv.hor_res    = 800;
-    disp_drv.ver_res    = 480;
+    disp_drv.flush_cb   = drm_flush;
+    lv_coord_t drm_width, drm_height;
+    /* get size from DRM/KMS backend */
+    uint32_t drm_dpi;
+    drm_get_sizes(&drm_width, &drm_height, &drm_dpi);
+    disp_drv.hor_res    = drm_width;
+    disp_drv.ver_res    = drm_height;
     lv_disp_drv_register(&disp_drv);
 
     evdev_init();
+
+    lv_group_t * g = lv_group_create();
+    lv_group_set_default(g);
+
     static lv_indev_drv_t indev_drv_1;
     lv_indev_drv_init(&indev_drv_1); /*Basic initialization*/
     indev_drv_1.type = LV_INDEV_TYPE_POINTER;
@@ -42,24 +131,49 @@ int main(void)
     indev_drv_1.read_cb = evdev_read;
     lv_indev_t *mouse_indev = lv_indev_drv_register(&indev_drv_1);
 
-
     /*Set a cursor for the mouse*/
     LV_IMG_DECLARE(mouse_cursor_icon)
     lv_obj_t * cursor_obj = lv_img_create(lv_scr_act()); /*Create an image object for the cursor */
     lv_img_set_src(cursor_obj, &mouse_cursor_icon);           /*Set the image source*/
     lv_indev_set_cursor(mouse_indev, cursor_obj);             /*Connect the image  object to the driver*/
+#elif USE_FBDEV
+    fbdev_init();
 
+    /*A small buffer for LittlevGL to draw the screen's content*/
+    static lv_color_t buf[DISP_BUF_SIZE];
 
-    /*Create a Demo*/
-    lv_demo_widgets();
+    /*Initialize a descriptor for the buffer*/
+    static lv_disp_draw_buf_t disp_buf;
+    lv_disp_draw_buf_init(&disp_buf, buf, NULL, DISP_BUF_SIZE);
 
-    /*Handle LitlevGL tasks (tickless mode)*/
-    while(1) {
-        lv_timer_handler();
-        usleep(5000);
-    }
+    /*Initialize and register a display driver*/
+    static lv_disp_drv_t disp_drv;
+    lv_disp_drv_init(&disp_drv);
+    disp_drv.draw_buf   = &disp_buf;
+    disp_drv.flush_cb   = fbdev_flush;
+    disp_drv.hor_res    = 800;
+    disp_drv.ver_res    = 480;
+    lv_disp_drv_register(&disp_drv);
 
-    return 0;
+    evdev_init();
+
+    lv_group_t * g = lv_group_create();
+    lv_group_set_default(g);
+
+    static lv_indev_drv_t indev_drv_1;
+    lv_indev_drv_init(&indev_drv_1); /*Basic initialization*/
+    indev_drv_1.type = LV_INDEV_TYPE_POINTER;
+
+    /*This function will be called periodically (by the library) to get the mouse position and state*/
+    indev_drv_1.read_cb = evdev_read;
+    lv_indev_t *mouse_indev = lv_indev_drv_register(&indev_drv_1);
+
+    /*Set a cursor for the mouse*/
+    LV_IMG_DECLARE(mouse_cursor_icon)
+    lv_obj_t * cursor_obj = lv_img_create(lv_scr_act()); /*Create an image object for the cursor */
+    lv_img_set_src(cursor_obj, &mouse_cursor_icon);           /*Set the image source*/
+    lv_indev_set_cursor(mouse_indev, cursor_obj);             /*Connect the image  object to the driver*/
+#endif
 }
 
 /*Set in lv_conf.h as `LV_TICK_CUSTOM_SYS_TIME_EXPR`*/
