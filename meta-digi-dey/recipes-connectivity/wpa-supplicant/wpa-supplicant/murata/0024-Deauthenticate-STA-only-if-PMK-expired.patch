From: Kurt Lee <kurt.lee@cypress.com>
Date: Mon, 28 Mar 2022 03:53:29 -0500
Subject: [PATCH] Deauthenticate STA only if PMK expired

Porting from commit 6aaac006af7fd39d618c6546939bed9f0f0cea37
which acts on hostapd. Don't deauthenticate STA when PMK is freed or
replaced
---
 src/ap/pmksa_cache_auth.c | 22 ++++++++++++----------
 src/ap/pmksa_cache_auth.h | 12 ++++++++++--
 src/ap/wpa_auth.c         |  7 ++++---
 3 files changed, 26 insertions(+), 15 deletions(-)

diff --git a/src/ap/pmksa_cache_auth.c b/src/ap/pmksa_cache_auth.c
index b67b8522e..8c733cde0 100644
--- a/src/ap/pmksa_cache_auth.c
+++ b/src/ap/pmksa_cache_auth.c
@@ -26,11 +26,12 @@ struct rsn_pmksa_cache {
 #define PMKID_HASH(pmkid) (unsigned int) ((pmkid)[0] & 0x7f)
 	struct rsn_pmksa_cache_entry *pmkid[PMKID_HASH_SIZE];
 	struct rsn_pmksa_cache_entry *pmksa;
 	int pmksa_count;

-	void (*free_cb)(struct rsn_pmksa_cache_entry *entry, void *ctx);
+	void (*free_cb)(struct rsn_pmksa_cache_entry *entry, void *ctx,
+			enum pmksa_free_reason reason);
 	void *ctx;
 };


 static void pmksa_cache_set_expiration(struct rsn_pmksa_cache *pmksa);
@@ -47,17 +48,18 @@ static void _pmksa_cache_free_entry(struct rsn_pmksa_cache_entry *entry)
 	bin_clear_free(entry, sizeof(*entry));
 }


 void pmksa_cache_free_entry(struct rsn_pmksa_cache *pmksa,
-			    struct rsn_pmksa_cache_entry *entry)
+			    struct rsn_pmksa_cache_entry *entry,
+			    enum pmksa_free_reason reason)
 {
 	struct rsn_pmksa_cache_entry *pos, *prev;
 	unsigned int hash;

 	pmksa->pmksa_count--;
-	pmksa->free_cb(entry, pmksa->ctx);
+	pmksa->free_cb(entry, pmksa->ctx, reason);

 	/* unlink from hash list */
 	hash = PMKID_HASH(entry->pmkid);
 	pos = pmksa->pmkid[hash];
 	prev = NULL;
@@ -99,11 +101,11 @@ void pmksa_cache_free_entry(struct rsn_pmksa_cache *pmksa,
 void pmksa_cache_auth_flush(struct rsn_pmksa_cache *pmksa)
 {
 	while (pmksa->pmksa) {
 		wpa_printf(MSG_DEBUG, "RSN: Flush PMKSA cache entry for "
 			   MACSTR, MAC2STR(pmksa->pmksa->spa));
-		pmksa_cache_free_entry(pmksa, pmksa->pmksa);
+		pmksa_cache_free_entry(pmksa, pmksa->pmksa, PMKSA_FREE);
 	}
 }


 static void pmksa_cache_expire(void *eloop_ctx, void *timeout_ctx)
@@ -113,17 +115,16 @@ static void pmksa_cache_expire(void *eloop_ctx, void *timeout_ctx)

 	os_get_reltime(&now);
 	while (pmksa->pmksa && pmksa->pmksa->expiration <= now.sec) {
 		wpa_printf(MSG_DEBUG, "RSN: expired PMKSA cache entry for "
 			   MACSTR, MAC2STR(pmksa->pmksa->spa));
-		pmksa_cache_free_entry(pmksa, pmksa->pmksa);
+		pmksa_cache_free_entry(pmksa, pmksa->pmksa, PMKSA_EXPIRE);
 	}

 	pmksa_cache_set_expiration(pmksa);
 }

-
 static void pmksa_cache_set_expiration(struct rsn_pmksa_cache *pmksa)
 {
 	int sec;
 	struct os_reltime now;

@@ -372,18 +373,18 @@ int pmksa_cache_auth_add_entry(struct rsn_pmksa_cache *pmksa,

 	/* Replace an old entry for the same STA (if found) with the new entry
 	 */
 	pos = pmksa_cache_auth_get(pmksa, entry->spa, NULL);
 	if (pos)
-		pmksa_cache_free_entry(pmksa, pos);
+		pmksa_cache_free_entry(pmksa, pos, PMKSA_REPLACE);

 	if (pmksa->pmksa_count >= pmksa_cache_max_entries && pmksa->pmksa) {
 		/* Remove the oldest entry to make room for the new entry */
 		wpa_printf(MSG_DEBUG, "RSN: removed the oldest PMKSA cache "
 			   "entry (for " MACSTR ") to make room for new one",
 			   MAC2STR(pmksa->pmksa->spa));
-		pmksa_cache_free_entry(pmksa, pmksa->pmksa);
+		pmksa_cache_free_entry(pmksa, pmksa->pmksa, PMKSA_FREE);
 	}

 	pmksa_cache_link_entry(pmksa, entry);

 	return 0;
@@ -537,11 +538,12 @@ struct rsn_pmksa_cache_entry * pmksa_cache_get_okc(
  * @ctx: Context pointer for free_cb function
  * Returns: Pointer to PMKSA cache data or %NULL on failure
  */
 struct rsn_pmksa_cache *
 pmksa_cache_auth_init(void (*free_cb)(struct rsn_pmksa_cache_entry *entry,
-				      void *ctx), void *ctx)
+				      void *ctx, enum pmksa_free_reason reason),
+		      void *ctx)
 {
 	struct rsn_pmksa_cache *pmksa;

 	pmksa = os_zalloc(sizeof(*pmksa));
 	if (pmksa) {
@@ -611,11 +613,11 @@ int pmksa_cache_auth_radius_das_disconnect(struct rsn_pmksa_cache *pmksa,
 	while (entry) {
 		if (das_attr_match(entry, attr)) {
 			found++;
 			prev = entry;
 			entry = entry->next;
-			pmksa_cache_free_entry(pmksa, prev);
+			pmksa_cache_free_entry(pmksa, prev, PMKSA_FREE);
 			continue;
 		}
 		entry = entry->next;
 	}

diff --git a/src/ap/pmksa_cache_auth.h b/src/ap/pmksa_cache_auth.h
index 2ef217435..9c942024d 100644
--- a/src/ap/pmksa_cache_auth.h
+++ b/src/ap/pmksa_cache_auth.h
@@ -32,16 +32,23 @@ struct rsn_pmksa_cache_entry {
 	int opportunistic;

 	u64 acct_multi_session_id;
 };

+enum pmksa_free_reason {
+	PMKSA_FREE,
+	PMKSA_REPLACE,
+	PMKSA_EXPIRE,
+};
+
 struct rsn_pmksa_cache;
 struct radius_das_attrs;

 struct rsn_pmksa_cache *
 pmksa_cache_auth_init(void (*free_cb)(struct rsn_pmksa_cache_entry *entry,
-				      void *ctx), void *ctx);
+				      void *ctx, enum pmksa_free_reason reason),
+		      void *ctx);
 void pmksa_cache_auth_deinit(struct rsn_pmksa_cache *pmksa);
 struct rsn_pmksa_cache_entry *
 pmksa_cache_auth_get(struct rsn_pmksa_cache *pmksa,
 		     const u8 *spa, const u8 *pmkid);
 struct rsn_pmksa_cache_entry * pmksa_cache_get_okc(
@@ -66,11 +73,12 @@ pmksa_cache_add_okc(struct rsn_pmksa_cache *pmksa,
 		    const u8 *aa, const u8 *pmkid);
 void pmksa_cache_to_eapol_data(struct hostapd_data *hapd,
 			       struct rsn_pmksa_cache_entry *entry,
 			       struct eapol_state_machine *eapol);
 void pmksa_cache_free_entry(struct rsn_pmksa_cache *pmksa,
-			    struct rsn_pmksa_cache_entry *entry);
+			    struct rsn_pmksa_cache_entry *entry,
+			    enum pmksa_free_reason reason);
 int pmksa_cache_auth_radius_das_disconnect(struct rsn_pmksa_cache *pmksa,
 					   struct radius_das_attrs *attr);
 int pmksa_cache_auth_list(struct rsn_pmksa_cache *pmksa, char *buf, size_t len);
 void pmksa_cache_auth_flush(struct rsn_pmksa_cache *pmksa);
 int pmksa_cache_auth_list_mesh(struct rsn_pmksa_cache *pmksa, const u8 *addr,
diff --git a/src/ap/wpa_auth.c b/src/ap/wpa_auth.c
index e92ea4302..36ab7e5b5 100644
--- a/src/ap/wpa_auth.c
+++ b/src/ap/wpa_auth.c
@@ -385,14 +385,15 @@ static int wpa_auth_pmksa_clear_cb(struct wpa_state_machine *sm, void *ctx)
 	return 0;
 }


 static void wpa_auth_pmksa_free_cb(struct rsn_pmksa_cache_entry *entry,
-				   void *ctx)
+				   void *ctx, enum pmksa_free_reason reason)
 {
 	struct wpa_authenticator *wpa_auth = ctx;
-	wpa_sta_disconnect(wpa_auth, entry->spa, WLAN_REASON_PREV_AUTH_NOT_VALID);
+	if (reason == PMKSA_EXPIRE)
+		wpa_sta_disconnect(wpa_auth, entry->spa, WLAN_REASON_PREV_AUTH_NOT_VALID);
 	wpa_auth_for_each_sta(wpa_auth, wpa_auth_pmksa_clear_cb, entry);
 }


 static int wpa_group_init_gmk_and_counter(struct wpa_authenticator *wpa_auth,
@@ -4892,11 +4893,11 @@ void wpa_auth_pmksa_remove(struct wpa_authenticator *wpa_auth,
 		return;
 	pmksa = pmksa_cache_auth_get(wpa_auth->pmksa, sta_addr, NULL);
 	if (pmksa) {
 		wpa_printf(MSG_DEBUG, "WPA: Remove PMKSA cache entry for "
 			   MACSTR " based on request", MAC2STR(sta_addr));
-		pmksa_cache_free_entry(wpa_auth->pmksa, pmksa);
+		pmksa_cache_free_entry(wpa_auth->pmksa, pmksa, PMKSA_FREE);
 	}
 }


 int wpa_auth_pmksa_list(struct wpa_authenticator *wpa_auth, char *buf,
